/* Brandon Robinson
 * CS220 / Pacheco
 * 13 Novemeber 2015
 * Project 4: MPI Bitonic Sort
 *
 * File: mpi_bitonic.c
 *
 * Purpose:
 *   Implement parallel bitonic sort of a list that is either user
 *   inputed or computer generated by the program using a random number
 *   generator.
 *
 * Compile:  
 *   gcc -g -Wall (-DDEBUG) -o mpi_bitonic mpi_bitonic.c -lm
 *
 * Run:
 *   ./mpi_bitonic <n> <'i'|'g'>
 *      n = number of elements in the list (a power of 2)
 *      'i':  user will enter list (no quotes)
 *      'g':  program will generate list (no quotes)
 *
 * Input:
 *    If command line option 'i' is used, the user will have to enter n
 *    elements. If 'g' is entered, the program will display unsorted list, 
 *    followed by the sorted list. 
 *
 * Output:
 *    The unsorted list and the sorted list.
 *    If DEBUG flag is entered in on the command line, the stages of the 
 *    butterflies will be disaplayed and the processes individual lists.
 *
 * Notes:
 *    1.  If the list is randomly generated, the keys are in the range 
 *       1 -- KEY_MAX.
 *    2.  The size of the list, n, should be a power of 2:  the program
 *       doesn't check that this is the case.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <mpi.h>
#define KEY_MAX 1000000

/* Sorting functons */
void Bitonic_sort_incr(int loc_list[], int loc_n, int i, int p, int my_rank,
                        MPI_Comm comm);
void Bitonic_sort_decr(int loc_list[], int loc_n, int i, int p, int my_rank, 
                        MPI_Comm comm);
void Merge_split_low(int local_A[], int temp_B[], int temp_C[], int local_n);
void Merge_split_high(int local_A[], int temp_B[], int temp_C[], int local_n);
int Compare(const void* x_p, const void* y_p);

/* Input Output functions */
void Get_args(int argc, char* argv[], int* n_p, char* ig_p);
void Read_list(char title[], int loc_list[], int loc_n, int n, int my_rank,
                MPI_Comm comm);
void Gen_list(int loc_list[], int loc_n, int n, int my_rank, MPI_Comm comm);
void Print_local_lists(int local_A[], int local_n, int my_rank, int p, 
                        MPI_Comm comm);
void Print_global_list(char title[], int local_A[], int local_n, int my_rank, 
                        int p, MPI_Comm comm);
void Print_list(int local_A[], int local_n, int rank);

/*---------------------------------------------------------------------------*/
int main(int argc, char* argv[]) {
   int n, loc_n, p, my_rank, i, *loc_list;
   unsigned and_bit;
   MPI_Comm comm;

   MPI_Init(&argc, &argv);
   comm = MPI_COMM_WORLD;
   MPI_Comm_size(comm, &p);
   MPI_Comm_rank(comm, &my_rank);
   char option;

   Get_args(argc, argv, &n, &option);

   loc_n = n/p;
   loc_list = malloc(loc_n*sizeof(int));

   if (option == 'i')
      Read_list("Enter the list", loc_list, loc_n, n, my_rank, comm);
   else
      Gen_list(loc_list, loc_n, n, my_rank, comm);
   
   Print_global_list("Original unsorted list is:", loc_list, loc_n, my_rank,
                     p, comm);

   qsort(loc_list, loc_n, sizeof(int), Compare); /* Local sort */

   for (i = 2, and_bit = 2; i <= p; i = i*2, and_bit<<=1) {
#    ifdef DEBUG
     if (my_rank==0)
       printf("Beginning %d-element butterfly\n", i);
#    endif      
     if ((my_rank & and_bit) == 0) {
       Bitonic_sort_incr(loc_list, loc_n, i, p, my_rank, comm);
#      ifdef DEBUG
       Print_global_list("Updated list for this butterfly:", loc_list, loc_n,
                          my_rank, p, comm);
#      endif
     } else {
       Bitonic_sort_decr(loc_list, loc_n, i, p, my_rank, comm);
#      ifdef DEBUG
       Print_global_list("Updated list for this butterfly:", loc_list, loc_n, 
                          my_rank, p, comm);
#      endif
     }
   }

   Print_global_list("The final sorted list is:", loc_list, loc_n, my_rank, 
                     p, comm);

   free(loc_list);

   MPI_Finalize();
   return 0;
}  /* main */


/*----------------------------------------------------------------------------
 * Function: Bitonic_sort_incr 
 * Purpose:
 * Input:    loc_list: process local list
 *           loc_n: local list size
 *           i: ith element process
 *           my_rank: process rank
 *           comm: MPI communicator
 */
void Bitonic_sort_incr(int loc_list[], int loc_n, int i, int p, int my_rank, 
                        MPI_Comm comm) {
  int        p_set = log2(i); /* The number of i-element butterflies */
  unsigned   bitmask = 1 << (p_set - 1); /* Bitmask left shift */
  int        partner, stage;
  int        *p_list, *merge_list;

  p_list = malloc(loc_n*sizeof(int));
  merge_list = malloc(loc_n*sizeof(int));

  for (stage = 0; stage < p_set; stage++) {
    partner = my_rank ^ bitmask;
    MPI_Sendrecv(loc_list, loc_n, MPI_INT, partner, 0, p_list, loc_n, 
                 MPI_INT, partner, 0, comm, MPI_STATUS_IGNORE);
    if (my_rank < partner ) {
      Merge_split_low(loc_list, p_list, merge_list, loc_n);
    } else {
      Merge_split_high(loc_list, p_list, merge_list, loc_n);
    }
    bitmask >>= 1;
#   ifdef DEBUG
    if (my_rank==0)
      printf("Stage %d completed with local lists:\n", stage);
    Print_local_lists(loc_list, loc_n, my_rank, p, comm);
#   endif
  }
  free(p_list);
  free(merge_list);
} /* Bitonic_sort_incr */


/*----------------------------------------------------------------------------
 * Function: Bitonic_sort_decr
 * Purpose:  Merge splits the ranks list with it's partners in a decreasing 
 *           sequence.
 * Input:    loc_list: process local list
 *           loc_n: local list size
 *           i: ith element process
 *           my_rank: process rank
 *           comm: MPI communicator
 */
void Bitonic_sort_decr(int loc_list[], int loc_n, int i, int p, int my_rank, 
                        MPI_Comm comm) {
  int        p_set = log2(i); /* The number of i-element butterflies */
  unsigned   bitmask = 1 << (p_set - 1); /* Bitmask left shift */
  int        partner, stage;
  int        *p_list, *merge_list;

  p_list = malloc(loc_n*sizeof(int));
  merge_list = malloc(loc_n*sizeof(int));

  for (stage = 0; stage < p_set; stage++) {
    partner = my_rank ^ bitmask;
    MPI_Sendrecv(loc_list, loc_n, MPI_INT, partner, 0, p_list, loc_n, 
                 MPI_INT, partner, 0, comm, MPI_STATUS_IGNORE);
    if (my_rank > partner ) {
      Merge_split_low(loc_list, p_list, merge_list, loc_n);
    } else {
      Merge_split_high(loc_list, p_list, merge_list, loc_n);
    }
    bitmask >>= 1;
#   ifdef DEBUG
    if (my_rank==0)
      printf("Stage %d completed with local lists:\n", stage);
    Print_local_lists(loc_list, loc_n, my_rank, p, comm);
#   endif
  }

  free(p_list);
  free(merge_list);
} /* Bitonic_sort_decr */


/*----------------------------------------------------------------------------
 * Function:    Merge_split_low
 * Purpose:     Merge the smallest local_n elements in local_A 
 *              and temp_B into temp_C.  Then copy temp_C
 *              back into local_A.
 * Input:       
 *    local_A: Local list of process
 *    temp_B: Partner list of process
 *    temp_c: The merged list that will be copied back into A
 *    local_n: local list size
 */
void Merge_split_low(int local_A[], int temp_B[], int temp_C[], int local_n) {
   int ai, bi, ci;
   
   ai = 0;
   bi = 0;
   ci = 0;
   while (ci < local_n) {
     if (local_A[ai] <= temp_B[bi]) {
       temp_C[ci] = local_A[ai];
       ci++; ai++;
     } else {
       temp_C[ci] = temp_B[bi];
       ci++; bi++;
     }
   }
   /* Copying the new list back into the local_list */
   memcpy(local_A, temp_C, local_n*sizeof(int));
}  /* Merge_split_low */


/*----------------------------------------------------------------------------
 * Function:    Merge_split_high 
 * Purpose:     Merge the largest local_n elements in local_A 
 *              and temp_B into temp_C.  Then copy temp_C
 *              back into local_A.
 * Input:       
 *    local_A: Local list of process
 *    temp_B: Partner list of process
 *    temp_c: The merged list that will be copied back into A
 *    local_n: local list size
 */
void Merge_split_high(int local_A[], int temp_B[], int temp_C[], int local_n) {
   int ai, bi, ci;
   
   ai = local_n-1;
   bi = local_n-1;
   ci = local_n-1;
   while (ci >= 0) {
     if (local_A[ai] >= temp_B[bi]) {
       temp_C[ci] = local_A[ai];
       ci--; ai--;
     } else {
       temp_C[ci] = temp_B[bi];
       ci--; bi--;
     }
   }
   /* Copying the new list back into the local_list */
   memcpy(local_A, temp_C, local_n*sizeof(int));
}  /* Merge_split_high */


/*----------------------------------------------------------------------------
 * Function:     Compare
 * Purpose:      Compare two ints and determine which is larger. Used 
 *               by qsort function to sort the local lists.
 * Input:          
 *     x_p, y_p
 * Return values:  
 *     -1 if *x_p < *y_p
 *     0 if *x_p == *y_p
 *     1 otherwise
 * Note:        For use by qsort library function
 */
int Compare(const void* x_p, const void* y_p) {
   int x = *((int*)x_p);
   int y = *((int*)y_p);

   if (x < y)
      return -1;
   else if (x == y)
      return 0;
   else /* x > y */
      return 1;
}  /* Compare */


/*----------------------------------------------------------------------------
 * Function:  Get_args
 * Purpose:   Get the command line arguments
 * Input:     
 *    argc: Number of command line arguments
 *    argv: list that contains the command line arguments
 * Output:  
 *    n_p:  pointer to list size
 *    ig_p:  pointer to 'i' if user will input list, otherwise pointer to '
 */
void Get_args(int argc, char* argv[], int* n_p, char* ig_p) {
  if (argc != 3) {
    fprintf(stderr, "usage: -n <p> %s <n> <'i'|'g'>\n", argv[2]);
    fprintf(stderr, "   <p> = number of processes (a power of 2)\n");
    fprintf(stderr, "   <n> = number of elements in the list (a power of 2)\n");
    fprintf(stderr, "   'i':  user will enter list (no quotes)\n");
    fprintf(stderr, "   'g':  program should generate list (no quotes)\n");
    exit(0);
   }
   *n_p = strtol(argv[1], NULL, 10);
   *ig_p = argv[2][0];
}  /* Get_args */


/*----------------------------------------------------------------------------
 * Function:  Read_list
 * Purpose:   Read in a list of ints and scatter them amongst the processes of 
 *            size n/p
 * Input:    
 *   title: string that is passed in from main
 *   loc_list: process local list allocated in main
 *   loc_n: n/p elements
 *   n: n elements
 *   my_rank: process rank
 *   comm: MPI communicator
 * Notes:    MPI_Scatter is used to distribute the list amongst the processes
 */
void Read_list(char title[], int loc_list[], int loc_n, int n, int my_rank, 
                MPI_Comm comm) {
   int* list = NULL, i;

   if (my_rank == 0) {
      list = malloc(n*sizeof(int));
      printf("%s\n", title);
      for (i = 0; i < n; i++)
         scanf("%d", &list[i]);
      printf("\n"); 
   }

   MPI_Scatter(list, loc_n, MPI_INT, loc_list, loc_n, MPI_INT, 0, comm);

   if (my_rank == 0) { 
      free(list);
   }
}  /* Read_list */


/*----------------------------------------------------------------------------
 * Function:  Gen_list
 * Purpose:   Use a random number generator to generate an n-element
 *            list and distribute it amongst the processes of size n/p
 * Input:      
 *   title: string that is passed in from main
 *   loc_list: process local list allocated in main
 *   loc_n: n/p elements
 *   n: n elements
 *   my_rank: process rank
 *   comm: MPI communicator
 * Note:      Elements of the list are in the range 1 -- KEY_MAX
 *            MPI_Scatter is used to distribute the list amongst the processes.
 */
void Gen_list(int loc_list[], int loc_n, int n, int my_rank, MPI_Comm comm) {
   int* list = NULL, i;

   if (my_rank==0) {
      list = malloc(n*sizeof(int));
      srandom(1);
      for (i = 0; i < n; i++)
         list[i] = 1 + random() % KEY_MAX;
      printf("\n");    
   }

   MPI_Scatter(list, loc_n, MPI_INT, loc_list, loc_n, MPI_INT, 0, comm);

   if (my_rank == 0) {  
      free(list);
   }
}  /* Gen_list */ 


/*----------------------------------------------------------------------------
 * Function: Print_list
 * Purpose: This function is only calle by process 0
 * Input:
 *    local_A: local list
 *    local_n: n/p elements
 *    my_rank: process rank
 */
void Print_list(int local_A[], int local_n, int my_rank) {
   int i;
   printf("%d: ", my_rank);
   for (i = 0; i < local_n; i++)
      printf("%d ", local_A[i]);
   printf("\n");
}  /* Print_list */


/*----------------------------------------------------------------------------
 * Function:   Print_global_list
 * Purpose:    Print the contents of the global list A
 * Input:  
 *    local_A: local list
 *    local_n: the number of elements 
 * Note:       Called only by process 0
 */
void Print_global_list(char title[], int local_A[], int loc_n, int my_rank, 
                        int p, MPI_Comm comm) {
   int* A = NULL;
   int i, n;

   if (my_rank == 0) {
      n = p*loc_n;
      A = (int*) malloc(n*sizeof(int));
      MPI_Gather(local_A, loc_n, MPI_INT, A, loc_n, MPI_INT, 0,
            comm);
      printf("%s\n", title);
      for (i = 0; i < n; i++)
         printf("%d ", A[i]);
      printf("\n\n");
      free(A);
   } else {
      MPI_Gather(local_A, loc_n, MPI_INT, A, loc_n, MPI_INT, 0,
            comm);
   }

}  /* Print_global_list */


/*----------------------------------------------------------------------------
 * Function:   Print_local_lists
 * Purpose:    Print each process' current list contents
 * Input:      local_A: local list
 * Notes:      Assumes all participating processes are contributing local_n 
 *     elements
 */
void Print_local_lists(int local_A[], int local_n, int my_rank, int p, 
                        MPI_Comm comm) {
   int*       A;
   int        q;
   MPI_Status status;

   if (my_rank == 0) {
      A = (int*) malloc(local_n*sizeof(int));
      Print_list(local_A, local_n, my_rank);
      for (q = 1; q < p; q++) {
         MPI_Recv(A, local_n, MPI_INT, q, 0, comm, &status);
         Print_list(A, local_n, q);
      }
      free(A);
   } else {
      MPI_Send(local_A, local_n, MPI_INT, 0, 0, comm);
   }
}  /* Print_local_lists */
